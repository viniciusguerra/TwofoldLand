<?xml version="1.0" encoding="utf-8"?>
<root><!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
	<data name="IKinetic.Drag" xml:space="preserve">
		<value>Permite arrastar uma Entidade se IsLoose for True. Desselecione-a para soltar</value>
	</data>
	<data name="IKinetic.IsLoose" xml:space="preserve">
		<value>Se True, o objeto pode ser arrastado. Se False, não</value>
	</data>
	<data name="IKinetic.Pull" xml:space="preserve">
		<value>Puxa a Entidade em sua direção</value>
	</data>
	<data name="IKinetic.Push" xml:space="preserve">
		<value>Empurra a Entidade na direção oposta à sua</value>
	</data>
	<data name="IKinetic.Push1" xml:space="preserve">
		<value>Empurra a Entidade na direção dada: left, right, back ou forward</value>
	</data>
	<data name="Item.AncientChestKey.Description" xml:space="preserve">
		<value>Dizem que Baús Anciãos são presentes da natureza. Aquele que o destrancar receberá poder em sua forma mais pura</value>
	</data>
	<data name="Item.AncientChestKey.Name" xml:space="preserve">
		<value>Chave de Baú Ancião</value>
	</data>
	<data name="IUnlockable.BinaryKey" xml:space="preserve">
		<value>O número binário que é chave para essa destrancar Entidade</value>
	</data>
	<data name="IUnlockable.Toggle" xml:space="preserve">
		<value>Abre ou fecha caso a Entidade esteja destrancada</value>
	</data>
	<data name="IUnlockable.Unlock" xml:space="preserve">
		<value>Abre a interface de Conversão Binária</value>
	</data>
	<data name="IUnlockable.Unlock1" xml:space="preserve">
		<value>Destranca se passado o valor de BinaryKey ou uma chave válida do Storage</value>
	</data>
	<data name="IUnlockable.Unlocked" xml:space="preserve">
		<value>True se a Entidade estiver destrancada, se não, False</value>
	</data>
	<data name="IVerbal.Messages" xml:space="preserve">
		<value>Mensagens expressadas por essa Entidade</value>
	</data>
	<data name="IVulnerable.CurrentHealth" xml:space="preserve">
		<value>Quantidade de resistência atual dessa Entidade. Se chegar a 0, ela morre</value>
	</data>
	<data name="IVulnerable.MaxHealth" xml:space="preserve">
		<value>Resistência total dessa Entidade</value>
	</data>
	<data name="TestScene.Strings.ChestSign1" xml:space="preserve">
		<value>Nenhum mortal pode violar um Baú Ancião por responder a uma linguagem esquecida</value>
	</data>
	<data name="TestScene.Strings.ChestSign2" xml:space="preserve">
		<value>A lenda diz que eles guardam poder em sua forma mais pura</value>
	</data>
	<data name="TestScene.Strings.CompilerSign1" xml:space="preserve">
		<value>É dito que O Compilador transforma pensamentos em realidade</value>
	</data>
	<data name="TestScene.Strings.CompilerSign2" xml:space="preserve">
		<value>Os Antigos conseguiam criar Magias quando próximos dele</value>
	</data>
	<data name="TestScene.Strings.CompilerSign3" xml:space="preserve">
		<value>Eles também o tinham como local seguro, onde suas energias eram renovadas</value>
	</data>
	<data name="UI.Codex.LevelUpButton" xml:space="preserve">
		<value>Evoluir</value>
	</data>
	<data name="UI.Codex.MethodsTitle" xml:space="preserve">
		<value>Métodos</value>
	</data>
	<data name="UI.Codex.PropertiesTitle" xml:space="preserve">
		<value>Propriedades</value>
	</data>
	<data name="UI.Codex.SelectSkillMessage" xml:space="preserve">
		<value>Selecione uma Habilidade</value>
	</data>
	<data name="UI.Codex.SkillsButton" xml:space="preserve">
		<value>Habilidades</value>
	</data>
	<data name="UI.Codex.SpellsButton" xml:space="preserve">
		<value>Magias</value>
	</data>
	<data name="UI.CollectableAcquired.DefinitionButton" xml:space="preserve">
		<value>Ir Para Definição</value>
	</data>
	<data name="UI.CollectableAcquired.ItemAcquired" xml:space="preserve">
		<value>Novo Item Adquirido!</value>
	</data>
	<data name="UI.CollectableAcquired.SkillAcquired" xml:space="preserve">
		<value>Habilidade Adquirida!</value>
	</data>
	<data name="UI.CollectableAcquired.SkillLeveledUp" xml:space="preserve">
		<value>Habilidade Evoluída!</value>
	</data>
	<data name="UI.Storage.ItemsTitle" xml:space="preserve">
		<value>Itens</value>
	</data>
	<data name="UI.Storage.SpellsTitle" xml:space="preserve">
		<value>Magias Carregadas</value>
	</data>
	<data name="UI.Terminal.Placeholder" xml:space="preserve">
		<value>Insira um Comando...</value>
	</data>
</root>